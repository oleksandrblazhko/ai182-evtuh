## Тестування для HTTP-розбиття та HTTP-контрабанди
| ID |
|---|
| WSTG-INPV-15 |

### Короткі відомості
У цьому розділі наведено приклади атак, які використовують певні функції протоколу HTTP, використовуючи слабкі сторони веб-програми або особливості способу, у який різні агенти інтерпретують HTTP-повідомлення. У цьому розділі буде проаналізовано дві різні атаки, спрямовані на певні заголовки HTTP:
- HTTP-розбиття
- HTTP-контрабанда

Перша атака використовує відсутність санітарної обробки вхідних даних, що дозволяє зловмиснику вставляти символи CR і LF у заголовки відповіді програми та «розбивати» цю відповідь на два різних HTTP-повідомлення. Мета атаки може бути різною: від отруєння кешу до міжсайтового сценарію.

У другій атаці зловмисник використовує той факт, що деякі спеціально створені HTTP-повідомлення можуть аналізуватися та інтерпретуватися різними способами залежно від агента, який їх отримує. Контрабанда HTTP вимагає певного рівня знань про різні агенти, які обробляють HTTP-повідомлення (веб-сервер, проксі-сервер, брандмауер), і тому буде включено лише в розділ тестування сірого ящика.

### Цілі тесту
- Оцінити, чи є програма вразливою до розбиття, визначивши можливі атаки
- Оцініти, чи є ланцюг зв’язку вразливим до контрабанди, визначивши, які можливі атаки можна здійснити

### Як тестувати

#### Тестування чорної скриньки

##### HTTP-розбиття
Деякі веб-програми використовують частину введених користувачем даних для генерування значень деяких заголовків своїх відповідей. Найпростішим прикладом є переспрямування, у яких цільова URL-адреса залежить від деякого значення, наданого користувачем. Скажімо, наприклад, що користувача просять вибрати стандартний чи розширений веб-інтерфейс. Вибір буде передано як параметр, який використовуватиметься в заголовку відповіді для запуску переспрямування на відповідну сторінку.

Точніше, якщо параметр «інтерфейс» має значення «розширений», програма відповість наступним чином:

```
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: http://victim.com/main.jsp?interface=advanced
<snip>
```

Отримавши це повідомлення, браузер переведе користувача на сторінку, зазначену в заголовку Location. Однак, якщо програма не фільтрує введені користувачем дані, можна буде вставити в параметр «інтерфейс» послідовність %0d%0a, яка представляє послідовність CRLF, яка використовується для розділення різних рядків. На цьому етапі тестувальники зможуть ініціювати відповідь, яка буде інтерпретована як дві різні відповіді будь-ким, хто аналізуватиме її, наприклад веб-кеш, що знаходиться між нами та програмою. Це може бути використано зловмисником, щоб отруїти цей веб-кеш, щоб він надавав неправдивий вміст у всіх наступних запитах.

Припустимо, що в попередньому прикладі тестер передає такі дані як параметр інтерфейсу:

`advanced%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a<html>Sorry,%20System%20Down</html>`

Таким чином, отримана відповідь від уразливої програми буде такою:

```
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: http://victim.com/main.jsp?interface=advanced
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 35

<html>Sorry,%20System%20Down</html>
<other data>
```

Веб-кеш побачить дві різні відповіді, тому, якщо зловмисник надішле, одразу після першого запиту, другий із запитом `/index.html`, веб-кеш зіставить цей запит із другою відповіддю та кешує його вміст, щоб усі наступні запити, спрямовані на `victim.com/index.html`, що проходять через цей веб-кеш, отримають повідомлення «система не працює». Таким чином зловмисник зможе ефективно псувати сайт для всіх користувачів, які використовують цей веб-кеш (весь Інтернет, якщо веб-кеш є зворотним проксі для веб-додатку).

#### Тестування сірої скриньки

##### HTTP-розбиття
Знання деяких деталей веб-програми та цілі атаки значною мірою допомагає успішному використанню HTTP Splitting. Наприклад, різні цілі можуть використовувати різні методи, щоб визначити, коли закінчується перше повідомлення HTTP і коли починається друге. Деякі використовуватимуть межі повідомлення, як у попередньому прикладі. Інші цілі припускатимуть, що різні повідомлення будуть передаватися різними пакетами. Інші виділять для кожного повідомлення певну кількість фрагментів попередньо визначеної довжини: у цьому випадку друге повідомлення має починатися точно на початку фрагмента, і це вимагатиме від тестувальника використання відступу між двома повідомленнями. Це може спричинити деякі проблеми, коли вразливий параметр потрібно надіслати в URL-адресу, оскільки дуже довгу URL-адресу, ймовірно, буде скорочено або відфільтровано. Сценарій «сірого ящика» може допомогти зловмиснику знайти обхідний шлях: наприклад, кілька серверів додатків дозволять надсилати запит за допомогою POST замість GET.

##### HTTP-контрабанда
Як згадувалося у вступі, HTTP Smuggling використовує різні способи аналізу та інтерпретації спеціально створеного HTTP-повідомлення різними агентами (браузерами, веб-кешами, брандмауерами програм). Цей відносно новий вид атаки вперше виявили Хаїм Лінхарт, Аміт Кляйн, Ронен Хелед і Стів Оррін у 2005 році. Існує кілька можливих застосувань, і ми проаналізуємо одне з найбільш вражаючих: обхід брандмауера програми. Щоб отримати детальнішу інформацію та інші сценарії, зверніться до оригінального технічного документу (посилання на яке знаходиться внизу цієї сторінки).

Існує кілька продуктів, які дають системним адміністраторам змогу виявляти та блокувати ворожі веб-запити залежно від відомого зловмисного шаблону, вбудованого в запит. Наприклад, розглянемо сумнозвісну стару атаку проходження каталогу Unicode проти сервера IIS, під час якої зловмисник міг зламати корінь www, видавши такий запит:

`http://target/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+<command_to_execute>`

Звичайно, цю атаку досить легко помітити та відфільтрувати за наявністю в URL-адресі таких рядків, як «..» та «cmd.exe». Однак IIS 5.0 досить прискіпливо ставиться до запитів POST, тіло яких становить до 48 Кбайт, і скорочує весь вміст, що перевищує це обмеження, якщо заголовок Content-Type відрізняється від application/x-www-form-urlencoded. Тестер пера може використати це, створивши дуже великий запит, структурований таким чином:

```
POST /target.asp HTTP/1.1        <-- Request #1
Host: target
Connection: Keep-Alive
Content-Length: 49225
<CRLF>
<49152 bytes of garbage>
```

```
POST /target.asp HTTP/1.0        <-- Request #2
Connection: Keep-Alive
Content-Length: 33
<CRLF>
```

```
POST /target.asp HTTP/1.0        <-- Request #3
xxxx: POST /scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir HTTP/1.0   <-- Request #4
Connection: Keep-Alive
<CRLF>
```

Тут відбувається те, що Запит №1 складається з 49223 байтів, який також включає рядки Запиту №2. Таким чином, брандмауер (або будь-який інший агент, окрім IIS 5.0) побачить запит №1, не зможе побачити запит №2 (його дані будуть лише частиною №1), побачить запит №3 та пропустить запит №4 (оскільки POST буде лише частиною фейкового заголовка xxxx).

Що станеться з IIS 5.0? Він припинить розбір запиту №1 відразу після 49152 байтів сміття (оскільки він досягне ліміту в 48 К=49152 байтів) і, отже, розбере запит №2 як новий окремий запит. Запит №2 стверджує, що його вміст становить 33 байти, що включає все до «xxxx:», через що IIS пропускає запит №3 (інтерпретується як частина запиту №2), але виявляє запит №4, оскільки його POST починається одразу після 33-го байту. або Запит №2. Це трохи складно, але справа в тому, що URL-адреса атаки не буде виявлена ​​брандмауером (вона буде інтерпретована як тіло попереднього запиту), але буде правильно проаналізована (і виконана) IIS.

Хоча у вищезгаданому випадку метод використовує помилку веб-сервера, існують інші сценарії, у яких ми можемо використовувати різні способи, якими різні пристрої з підтримкою HTTP аналізують повідомлення, які не відповідають 1005 RFC. Наприклад, протокол HTTP дозволяє лише один заголовок Content-Length, але не вказує, як обробляти повідомлення, яке містить два екземпляри цього заголовка. Деякі реалізації використовуватимуть перший, тоді як інші віддадуть перевагу другому, очищаючи шлях для атак HTTP Smuggling. Іншим прикладом є використання заголовка Content-Length у повідомленні GET.

Зауважте, що HTTP Smuggling *не* використовує будь-яку вразливість цільової веб-програми. Таким чином, може бути дещо складно переконати клієнта в тому, що в будь-якому випадку слід шукати контрзаходи.
